#lang dssl2

# HW7: Trip Planner
#
# ** You must work on your own for this assignment. **
let eight_principles = ["Know your rights.",
                        "Acknowledge your sources.",
                        "Protect your work.",
                        "Avoid suspicion.",
                        "Do your own work.",
                        "Never falsify a record or permit another person to do so.",
                        "Never fabricate data, citations, or experimental results.",
                        "Always tell the truth when discussing your work with your instructor."]

# Your program will most likely need a number of data structures, many of
# which you've implemented in previous homeworks.
# We have provided you with compiled versions of homework 3, 4, 5, and 6
# solutions. You can import them as you did in homework 6.
# Be sure to extract the `hw7-lib` archive is the same directory as this file.
# You may also import libraries from the DSSL2 standard library (e.g., cons,
# array, etc.).

import cons
import sbox_hash
import 'hw7-lib/dictionaries.rkt'
import 'hw7-lib/graph.rkt'
import 'hw7-lib/binheap.rkt'
import 'hw7-lib/unionfind.rkt'

### Basic Vocabulary Types ###

#  - Latitudes and longitudes are numbers:
let Lat?  = num?
let Lon?  = num?
#  - Point-of-interest categories and names are strings:
let Cat?  = str?
let Name? = str?

# ListC[T] is a list of `T`s (linear time):
let ListC = Cons.ListC

# List of unspecified element type (constant time):
let List? = Cons.list?



### Input Types ###

#  - a SegmentVector  is VecC[SegmentRecord]
#  - a PointVector    is VecC[PointRecord]
# where
#  - a SegmentRecord  is [Lat?, Lon?, Lat?, Lon?]
#  - a PointRecord    is [Lat?, Lon?, Cat?, Name?]


### Output Types ###

#  - a NearbyList     is ListC[PointRecord]; i.e., one of:
#                       - None
#                       - cons(PointRecord, NearbyList)
#  - a PositionList   is ListC[Position]; i.e., one of:
#                       - None
#                       - cons(Position, PositionList)
# where
#  - a PointRecord    is [Lat?, Lon?, Cat?, Name?]  (as above)
#  - a Position       is [Lat?, Lon?]


# Interface for trip routing and searching:
interface TRIP_PLANNER:
    # Finds the shortest route, if any, from the given source position
    # (latitude and longitude) to the point-of-interest with the given
    # name. (Returns the empty list (`None`) if no path can be found.)
    def find_route(
            self,
            src_lat:  Lat?,     # starting latitude
            src_lon:  Lon?,     # starting longitude
            dst_name: Name?     # name of goal
        )   ->        List?     # path to goal (PositionList)

    # Finds no more than `n` points-of-interest of the given category
    # nearest to the source position. (Ties for nearest are broken
    # arbitrarily.)
    def find_nearby(
            self,
            src_lat:  Lat?,     # starting latitude
            src_lon:  Lon?,     # starting longitude
            dst_cat:  Cat?,     # point-of-interest category
            n:        nat?      # maximum number of results
        )   ->        List?     # list of nearby POIs (NearbyList)

        
struct Posn:
    let x: Lat?
    let y: Lon?
    
struct Road:
    let Posn1
    let Posn2

struct PoI:
    let Posn
    let Catagory
    let Name
    
struct vertex_dist_pair:
    let vertex
    let distance
    
struct path_dist_pair:
    let path
    let distance
    
struct PoI_dist_pair:
    let PoI
    let distance
    

    

def find_shortest_path(graph,start,end):

    let dist = [inf ; graph.len()]
    let pred = [None; graph.len()]
    dist[start] = 0
    
    let todo = BinHeap(graph.len(),λ x, y: x.distance < y.distance)
    todo.insert(vertex_dist_pair(start,dist[start]))
    let done = [False; graph.len()]
    
    while todo.len() != 0:
        let v = todo.find_min().vertex
        todo.remove_min()
        
        if not done[v]:
            done[v] = True
            for u in Cons.to_vec(graph.get_adjacent(v)):
                if dist[v] + graph.get_edge(u,v) < dist[u]:
                    dist[u] = dist[v] + graph.get_edge(u,v)
                    pred[u] = v
                    todo.insert(vertex_dist_pair(u,dist[u]))
                            
    let path = None
    let u = end
    let distance = dist[u]
    while pred[u] != None:
        path = cons(u,path)
        u = pred[u]
    #if u is start, then we've found a complete path
    if u == start:
        #give it a good format (still reversed)
        path = cons(start,path)
        return path_dist_pair(path,distance)
    else:
        return None  


                    
              
                
       
        

class TripPlanner (TRIP_PLANNER):
    let road_graph
    let Posn_to_node
    let node_to_Posn
    let name_to_PoI
    let cat_to_PoI    
        
    
    def __init__(self,list_of_road,list_of_PoI):
        
        let road_len = list_of_road.len()
        let PoI_len = list_of_PoI.len()
        
        
        #to account for the posn in both road and PoI
        self.Posn_to_node = HashTable(road_len * 2 + PoI_len, SboxHash64().hash)
        self.node_to_Posn = HashTable(road_len * 2 + PoI_len, SboxHash64().hash)
        
        #the node_id is assigned to a new posn
        let node_id = 0
        
        #add new posn from list of road to the Hashtable
        for road in list_of_road:
            let Posn1 = Posn(road[0],road[1])
            let Posn2 = Posn(road[2],road[3])
            
            if not self.Posn_to_node.mem?(Posn1):
                self.Posn_to_node.put(Posn1,node_id)
                self.node_to_Posn.put(node_id,Posn1)
                node_id = node_id + 1
            if not self.Posn_to_node.mem?(Posn2):
                self.Posn_to_node.put(Posn2,node_id)
                self.node_to_Posn.put(node_id,Posn2)
                node_id = node_id + 1
        
        #add new posn from list of PoI to the Hashtable                     
        for PoI in list_of_PoI:
            let Posn3 = Posn(PoI[0],PoI[1])
            
            if not self.Posn_to_node.mem?(Posn3):
                self.Posn_to_node.put(Posn3,node_id)
                self.node_to_Posn.put(node_id,Posn3)
                node_id = node_id + 1
        
        #construct road_graph        
        self.road_graph = WuGraph(node_id)
        
        for road in list_of_road:
            let Posn1 = Posn(road[0],road[1])
            let Posn2 = Posn(road[2],road[3])
            #square root?
            let dist = ((road[2] - road[0]) * (road[2] - road[0]) + (road[3] - road[1]) * (road[3] - road[1])).sqrt()
            self.road_graph.set_edge(self.Posn_to_node.get(Posn1),self.Posn_to_node.get(Posn2),dist)
                
        self.name_to_PoI = HashTable(PoI_len,SboxHash64().hash)
        for PoI in list_of_PoI:
            self.name_to_PoI.put(PoI[3],PoI)
            
        self.cat_to_PoI = HashTable(PoI_len,SboxHash64().hash)
        for PoI in list_of_PoI:
            if self.cat_to_PoI.mem?(PoI[2]):
                let current = self.cat_to_PoI.get(PoI[2])
                self.cat_to_PoI.put(PoI[2],cons(PoI,self.cat_to_PoI.get(PoI[2])))
            else:
                self.cat_to_PoI.put(PoI[2],cons(PoI,None))

            
       
            
        
            
    
               
        
    def find_route(self,src_lat:Lat?,src_lon:Lon?,dst_name: Name?) -> List?:
        if not (self.name_to_PoI.mem?(dst_name) and self.Posn_to_node.mem?(Posn(src_lat,src_lon))):
            return None
        let start = self.Posn_to_node.get(Posn(src_lat,src_lon))
        let end = self.Posn_to_node.get(Posn(self.name_to_PoI.get(dst_name)[0],self.name_to_PoI.get(dst_name)[1]))
        if find_shortest_path(self.road_graph,start,end) == None:
            return None
        let path = Cons.to_vec(Cons.rev(find_shortest_path(self.road_graph,start,end).path))
        if path == None:
            return None
        let posn_path = None
        for vertex in path:
            posn_path = cons([self.node_to_Posn.get(vertex).x,self.node_to_Posn.get(vertex).y],posn_path)
        return posn_path
         
    
    def find_nearby(self,src_lat:Lat?,src_lon:Lon?,dst_cat: Cat?,n: nat?) -> List?:
        if not (self.cat_to_PoI.mem?(dst_cat) and self.Posn_to_node.mem?(Posn(src_lat,src_lon))):
            return None
        let list = None
        let start = self.Posn_to_node.get(Posn(src_lat,src_lon))
        let PoI_list = Cons.to_vec(self.cat_to_PoI.get(dst_cat))
        let node_heap = BinHeap(PoI_list.len(), λ x, y: x.distance < y.distance)
        for PoI in PoI_list: 
            let PoI_Posn = Posn(PoI[0],PoI[1])
            let shortest_path = find_shortest_path(self.road_graph,start,self.Posn_to_node.get(PoI_Posn))
            if shortest_path != None:
                node_heap.insert(PoI_dist_pair(PoI,shortest_path.distance))
        for i in range(n):
            if node_heap.len() != 0:
               list = (cons(node_heap.find_min().PoI,list))
               node_heap.remove_min()
        return Cons.rev(list)
            
            
        
        
#### ^^^ YOUR CODE HERE


def my_first_example():
    return TripPlanner([[0,0, 0,1], [0,0, 1,0]],
                       [[0,0, "bar", "The Empty Bottle"],
                        [0,1, "food", "Pelmeni"]])
    
test 'My first find_route test':
   assert my_first_example().find_route(0, 0, "Pelmeni") == \
       cons([0,0], cons([0,1], None))

test 'My first find_nearby tet':
   assert my_first_example().find_nearby(0, 0, "food", 1) == \
       cons([0,1, "food", "Pelmeni"], None)

def example_from_handout():
    return TripPlanner([[0,0,0,1],[0,0,1,0],[1,0,1,1],[0,1,1,1],[1,1,1,2],[0,1,0,2],[0,2,1,2],[1,2,1,3],[1,3,-0.2,3.3]],
                       [[0,0,"food","Sandwiches"],[0,1,"food","Pasta"],[1,1,"bank","Local Credit Union"],
                        [1,3,"bar","Bar None"],[1,3,"bar","H Bar"],[-0.2,3.3,"food","Burritos"]])
                        
test 'example_from_handout find_route test':
    assert example_from_handout().find_route(0,0,"Sandwiches") == cons([0,0],None)
    assert example_from_handout().find_route(0,1,"Sandwiches") == cons([0,1],cons([0,0],None))
    assert example_from_handout().find_route(1,1,"Sandwiches") == cons([1,1],cons([0,1],cons([0,0],None)))
    assert example_from_handout().find_route(1,1,"Burritos") == cons([1,1],cons([1,2],cons([1,3],cons([-0.2,3.3],None))))
    assert example_from_handout().find_route(1,1,"Sushi") == None
    assert example_from_handout().find_route(1,0,"Burritos") == cons([1,0],cons([1,1],cons([1,2],cons([1,3],cons([-0.2,3.3],None)))))
    
test 'example_from_handout find_nearby test':
    assert example_from_handout().find_nearby(1,3,"food",1) == cons([-0.2,3.3,"food","Burritos"],None)
    assert example_from_handout().find_nearby(0,2,"food",1) == cons([0,1,"food","Pasta"],None)
    assert example_from_handout().find_nearby(0,2,"food",2) == cons([0,1,"food","Pasta"],cons([0,0,"food","Sandwiches"],None))
    assert example_from_handout().find_nearby(0,2,"food",3) == cons([0,1,"food","Pasta"],cons([0,0,"food","Sandwiches"],cons([-0.2,3.3,"food","Burritos"],None)))
    assert example_from_handout().find_nearby(0,2,"food",4) == cons([0,1,"food","Pasta"],cons([0,0,"food","Sandwiches"],cons([-0.2,3.3,"food","Burritos"],None)))
    assert example_from_handout().find_nearby(0,2,"bar",1) == cons([1,3,"bar","H Bar"],None)
    assert example_from_handout().find_nearby(0,2,"bar",2) == cons([1,3,"bar","H Bar"],cons([1,3,"bar","Bar None"],None))
    assert example_from_handout().find_nearby(0,2,"bar",3) == cons([1,3,"bar","H Bar"],cons([1,3,"bar","Bar None"],None))
    assert example_from_handout().find_nearby(0,2,"school",5) == None
    
   
def disconnected_graph():
    return TripPlanner([[0,0,1,0],[1,0,0,0],[0,1,1,1],[1,1,0,1]],[[0,0,"bar","Bar A"],[0,0,"bar","Bar B"],[1,0,"bar","Bar C"],[0,1,"bar","Bar D"]])
    
test 'disconnected_graph find_route test':
    assert disconnected_graph().find_route(0,0,"Bar B") == cons([0,0],None)
    assert disconnected_graph().find_route(0,0,"Bar D") == None 
    assert disconnected_graph().find_route(1,1,"Bar D") == cons([1,1],cons([0,1],None))
    assert disconnected_graph().find_route(1,1,"Bar A") == None
    assert disconnected_graph().find_route(1,0.1,"Bar A") == None
    assert disconnected_graph().find_route(1,0,"Ba Bar??") == None
    
test 'disconnected_graph find_nearby test':
    assert disconnected_graph().find_nearby(0,0,"food",1)  == None
    assert disconnected_graph().find_nearby(0,0,"bar",0)  == None
    assert disconnected_graph().find_nearby(0,0,"bar",1) == cons([0,0,"bar","Bar B"],None)
    assert disconnected_graph().find_nearby(0,0,"bar",2) == cons([0,0,"bar","Bar B"],cons([0,0,"bar","Bar A"],None))
    assert disconnected_graph().find_nearby(0,0,"bar",3) == cons([0,0,"bar","Bar B"],cons([0,0,"bar","Bar A"],cons([1,0,"bar","Bar C"],None)))
    assert disconnected_graph().find_nearby(0,0,"bar",4) == cons([0,0,"bar","Bar B"],cons([0,0,"bar","Bar A"],cons([1,0,"bar","Bar C"],None)))
    assert disconnected_graph().find_nearby(0,0.1,"bar",4) == None
    
    

#### ^^^ YOUR CODE HERE
